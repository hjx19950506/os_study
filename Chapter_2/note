修改bootsect.s和bulid.c中的SETUPLEN参数
setup.s由bootsect.s修改而来，要注意int10的0X0e和0x13功能号的打印字符的区别，主要导致了是否需要读一次光标


BIOS
	PC上电从0xFFFF0处开始执行BIOS，完成系统自检，在物理地址0处初始化中断向量，
	从磁盘的第一个扇区将bootsect读到内存的0x7c00处，然后从该处开始执行

bootsect（Intel的as86汇编）
	将磁盘中接着bootsect后面4个扇区的setup读到0X90200处，system模块读到0x10000处，
	确定根文件系统设备号存在相对地址508处，最后跳转到setup处执行

setup	（Intel的as86汇编）
	利用BIOS中断读取机器的硬件参数，存在0x90000处，然后将system模块搬至0x00000处，
	加载idtr和gdtr(此时两个表在setup内的区域)，开始A20地址线，			
	重设两个中断控制芯片，将硬件中断号重设为0x20-0x2f，
	最后设置CPU的控制寄存器CR0的PE位，进入32位保护模式运行，
	最后跳转到system模块最前面的head部分运行

head	（AT&A的GNU as汇编）
	加载各个数据段寄存器，重设idt、gdt（在head内的区域），检查A20是否开启，
	设置CR0标志位以检查是否含有数字协处理芯片，先利用push为之后跳转main做好准备，
	设置管理内存的分页处理机制，最后利用push和ret配合转而执行main
	
setup中的idt其实是虚设，gdt设置是为了在启动保护模式后成功跳到0地址处
head中的idt初始化为256个8字节的0，然后将他们设置为都指向只报错的哑中断子程序ignore_int
	
内存分页处理机制：
	head会设置页目录表会放在0x0000处，覆盖当前程序头部分，
	紧随其后的0X1000、0x2000、0x3000、0x4000是4个页表，
	在setup_paging中先将这5*4KB内容清零，然后先写目录，再写页表
	页目录表大小为4KB，一个项占4B
	每个页表大小为4KB，一个页表项占4B（12-31位是地址，共管理4MB内存），所以一共管理4*4*1024=16MB内存
